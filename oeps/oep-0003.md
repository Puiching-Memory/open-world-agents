OEP: 3
Title: Entry Points-Based Plugin Discovery and Unified Component Naming
Author: Open World Agents Team
Status: Draft
Type: Standards Track
Created: 07-Jan-2025
Post-History: 07-Jan-2025

Abstract
========

This OEP proposes a standardized plugin discovery mechanism for Open World Agents using Python's entry points system, eliminating the need for manual `activate_module()` calls. The proposal also introduces unified `namespace/name` naming conventions for all component types (callables, listeners, runnables) and provides enhanced component access APIs. This change aligns OWA with Python packaging standards, simplifies plugin usage, and improves developer experience through automatic plugin discovery and consistent naming patterns.

Motivation
==========

The current OWA plugin system has several limitations that hinder developer experience and adoption:

**Manual Activation Requirement**: Users must explicitly call `activate_module()` for each plugin they want to use, creating friction and requiring knowledge of which plugins are installed.

```python
# Current system requires manual activation
from owa.core.registry import activate_module
activate_module("owa.env.std")
activate_module("owa.env.example")
```

**Inconsistent Naming Conventions**: Different component types use different naming patterns, creating confusion:
- Callables use dot notation: `"clock.time_ns"`
- Listeners and Runnables use slash notation: `"example/events"`

**Non-Standard Discovery**: The current system doesn't follow Python packaging standards for plugin discovery, making it unfamiliar to Python developers and incompatible with standard tooling.

**Limited Discoverability**: Users have difficulty discovering what plugins are available and what components they provide without consulting documentation or source code.

These issues create barriers to adoption and make the plugin system feel non-Pythonic compared to other frameworks that use standard entry points for plugin discovery.

Rationale
=========

**Entry Points Selection**: Python's entry points mechanism was chosen because it is the official standard for plugin discovery as documented in the Python Packaging Guide. Entry points provide:
- Metadata-based discovery without filesystem scanning
- Reliable operation across different Python environments
- Tool support from pip, setuptools, and other packaging tools
- Performance benefits through cached metadata

**Unified Naming Convention**: The `namespace/name` pattern was selected for all component types because:
- It provides consistency across all component types
- It aligns with common patterns in other plugin systems
- It's more intuitive than mixed dot/slash notation
- It supports hierarchical organization of components

**Hybrid Plugin Architecture**: Supporting both simple module and package structures accommodates different plugin complexities:
- Simple plugins can use a single module file
- Complex plugins can use package structure with separate files
- Developers can choose the appropriate structure for their needs

**Automatic Discovery**: Eliminating `activate_module()` reduces friction and follows the principle of least surprise - installed plugins should work immediately.

Specification
=============

## Plugin Declaration

Plugins declare themselves using Python entry points in `pyproject.toml`:

```toml
[project.entry-points."owa.env.plugins"]
example = "owa.env.example:plugin_spec"
```

## Plugin Specification Format

Each plugin must provide a `PluginSpec` object that defines its components:

```python
from owa.core.plugin_spec import PluginSpec

plugin_spec = PluginSpec(
    namespace="example",
    version="0.1.0", 
    description="Example environment plugin",
    author="Plugin Author",
    components={
        "callables": {
            "add": "owa.env.example:add_numbers",
            "print": "owa.env.example:enhanced_print",
        },
        "listeners": {
            "events": "owa.env.example:EventListener",
        },
        "runnables": {
            "processor": "owa.env.example:DataProcessor",
        }
    }
)
```

## Unified Component Naming

All components use the `namespace/name` pattern:
- Callables: `"example/add"`, `"std/time_ns"`
- Listeners: `"example/events"`, `"std/tick"`  
- Runnables: `"example/processor"`, `"std/monitor"`

## Plugin Architecture Options

**Simple Module Structure** (for small plugins):
```
owa-env-example/
├── pyproject.toml
├── owa/env/example.py    # All components in one file
└── tests/test_example.py
```

**Package Structure** (for complex plugins):
```
owa-env-example/
├── pyproject.toml
├── owa/env/example/
│   ├── __init__.py       # Plugin specification
│   ├── callables.py      # Callable implementations  
│   ├── listeners.py      # Listener implementations
│   └── runnables.py      # Runnable implementations
└── tests/
```

## Automatic Discovery Process

1. On OWA startup, scan for entry points in the `"owa.env.plugins"` group
2. Load each plugin's `PluginSpec` object via the entry point
3. Register all components with unified `namespace/name` naming
4. Components are immediately available in registries

## Enhanced Component Access API

```python
from owa.core.registry import get_component, list_components

# Get specific component
add_func = get_component("callables", namespace="example", name="add")

# Get all components in namespace  
example_callables = get_component("callables", namespace="example")

# List available components
all_callables = list_components("callables")
example_components = list_components(namespace="example")
```

## Entry Points Discovery Implementation

The core discovery system uses `pkg_resources` to find and load plugins:

```python
import pkg_resources
from owa.core.plugin_spec import PluginSpec
from owa.core.registry import CALLABLES, LISTENERS, RUNNABLES

class EntryPointPluginRegistry:
    def auto_discover(self):
        """Automatically discover and register all plugins via Entry Points."""
        for entry_point in pkg_resources.iter_entry_points('owa.env.plugins'):
            try:
                plugin_spec = entry_point.load()
                if isinstance(plugin_spec, PluginSpec):
                    self.register_plugin_components(plugin_spec)
            except Exception as e:
                print(f"Warning: Could not load plugin {entry_point.name}: {e}")

    def register_plugin_components(self, spec: PluginSpec):
        """Register all components from a plugin specification."""
        for component_type, components in spec.components.items():
            registry = self.get_registry(component_type)
            for name, module_path in components.items():
                full_name = f"{spec.namespace}/{name}"
                component = self.import_component(module_path)
                registry.register(full_name)(component)
```

Backwards Compatibility
=======================

This proposal introduces breaking changes that require migration:

**Breaking Changes**:
1. `activate_module()` calls must be removed
2. Component names must be updated to use `namespace/name` format
3. Plugins must add entry point declarations to `pyproject.toml`

**Migration Path**:

**Phase 1 - Dual Support** (Transition Period):
- Support both old and new naming conventions
- Deprecation warnings for old patterns
- Automatic migration tools for common cases

**Phase 2 - New System Only**:
- Remove support for old naming conventions
- Remove `activate_module()` function
- Entry points become the only discovery mechanism

**Migration Example**:
```python
# Before (OWA v0.x)
from owa.core.registry import CALLABLES, activate_module
activate_module("owa.env.std")
time_func = CALLABLES["clock.time_ns"]

# After (OWA v1.x)
from owa.core.registry import CALLABLES
time_func = CALLABLES["std/time_ns"]  # Auto-discovered
```

**Plugin Migration**:
Existing plugins need to:
1. Add entry point declaration to `pyproject.toml`
2. Create `PluginSpec` object
3. Update component references to use new naming

Security Implications
=====================

**Entry Point Security**: Entry points are loaded and executed during plugin discovery, which could allow malicious code execution if untrusted packages are installed. This is consistent with the general Python security model where installing packages grants code execution privileges.

**Mitigation Strategies**:
- Plugin discovery errors are logged but don't crash the system
- Invalid plugins are skipped with warnings
- Users should only install plugins from trusted sources
- Future versions could add plugin signing/verification

**No Additional Risk**: This proposal doesn't introduce new security risks beyond those inherent in the Python packaging ecosystem. The current `activate_module()` system has the same code execution implications.

How to Teach This
=================

**For Plugin Users**:
1. **Installation**: `pip install owa-env-example`
2. **Usage**: Components are immediately available with `namespace/name` syntax
3. **Discovery**: Use `owl env list` to see available plugins and components

**For Plugin Developers**:
1. **Quick Start**: Use plugin template generator (future feature)
2. **Entry Points**: Learn standard Python entry points declaration
3. **Plugin Spec**: Understand `PluginSpec` format and component organization
4. **Testing**: Test plugins in isolation and integration scenarios

**Documentation Updates**:
- Update plugin development guide with entry points examples
- Create migration guide for existing plugins
- Add troubleshooting section for common entry point issues
- Provide best practices for plugin organization

**Examples and Tutorials**:
- Step-by-step plugin creation tutorial
- Migration examples for common plugin patterns
- CLI usage examples for plugin management

Reference Implementation
========================

A proof-of-concept implementation is available in the `feature/entry-points-plugins` branch, including:

**Core Components**:
- `owa.core.plugin_spec.PluginSpec` class for plugin specifications
- `owa.core.registry.EntryPointPluginRegistry` for automatic discovery
- Enhanced `get_component()` and `list_components()` functions
- Updated CLI commands in `owl env` for plugin management

**Example Plugin**:
- `owa-env-example` package demonstrating both simple module and package structures
- Complete `pyproject.toml` configuration with entry points
- Test suite covering plugin discovery and component registration

**Migration Tools**:
- Automatic detection of old-style plugin usage
- Warning system for deprecated patterns
- Helper scripts for updating existing plugins

The implementation maintains full backwards compatibility during the transition period and includes comprehensive test coverage for the new discovery mechanism.

Rejected Ideas
==============

**Namespace Scanning**: Automatically scanning `owa.env.*` modules was rejected because:
- It requires filesystem access and is less reliable
- It doesn't work well with different installation methods
- It's not the Python standard for plugin discovery
- It can't distinguish between installed and development plugins

**YAML Configuration Files**: Using `plugin.yaml` files for plugin metadata was rejected because:
- YAML files aren't included in pip packages by default
- It requires additional file handling and parsing
- Entry points provide the same metadata capabilities
- It's not aligned with Python packaging standards

**Single Module Only**: Requiring all plugins to use single module structure was rejected because:
- Complex plugins benefit from package organization
- It limits plugin development flexibility
- The hybrid approach accommodates different needs
- Package structure is more maintainable for large plugins

**Keeping Dot Notation**: Maintaining `namespace.name` for callables was rejected because:
- Inconsistency with other component types creates confusion
- Unified naming is more intuitive and predictable
- Migration cost is justified by long-term benefits
- Slash notation is more common in plugin systems

Open Issues
===========

**Plugin Versioning**: How to handle version conflicts when multiple versions of the same plugin are installed. Current proposal uses the first discovered version.

**Plugin Dependencies**: How plugins should declare dependencies on other plugins. This may require extending the `PluginSpec` format.

**Hot Reloading**: Whether to support dynamic plugin loading/unloading during runtime. Current proposal focuses on startup-time discovery.

**Namespace Conflicts**: How to handle conflicts when multiple plugins claim the same namespace. Current proposal uses first-wins strategy with warnings.

**CLI Integration**: Final design for `owl env` commands for plugin management, validation, and troubleshooting.

References
==========

1. Python Packaging Guide - Creating and discovering plugins: https://packaging.python.org/en/latest/guides/creating-and-discovering-plugins/
2. Python Entry Points Specification: https://packaging.python.org/en/latest/specifications/entry-points/
3. setuptools Entry Points Documentation: https://setuptools.pypa.io/en/latest/userguide/entry_point.html
4. pkg_resources API Documentation: https://setuptools.pypa.io/en/latest/pkg_resources.html

Copyright
=========

This document is placed in the public domain or under the CC0-1.0-Universal license, whichever is more permissive.
