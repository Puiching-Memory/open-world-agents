OEP: 4
Title: Automatic EnvPlugin Documentation Generation and Display
Author: Open World Agents Team
Status: Draft
Type: Standards Track
Requires: 3
Created: 01-Feb-2025
Post-History: 01-Feb-2025

Abstract
========

This OEP introduces an automatic documentation generation system for EnvPlugins that extracts and aggregates docstrings directly from component source code into comprehensive plugin documentation. Similar to `mkdocstrings`, this system automatically discovers, parses, and generates complete plugin documentation from existing code docstrings without requiring manual documentation maintenance. Building upon the entry points-based plugin system from OEP-3, this specification enables users to view complete plugin documentation through CLI commands and automatically generated documentation sites.

Motivation
==========

The current OEP-3 plugin system provides excellent component discovery and access capabilities, but documentation visibility remains fragmented:

1. **Component-Level Documentation Only**: Users can only view docstrings for individual components using `owl env show <namespace> --inspect <component>`, requiring multiple commands to understand a plugin's full capabilities
2. **No Automatic Documentation Extraction**: Unlike tools like `mkdocstrings`, there's no system to automatically extract and aggregate all docstrings from plugin source code into comprehensive documentation
3. **Manual Documentation Maintenance**: Plugin developers must manually maintain separate documentation files, leading to synchronization issues and outdated information
4. **Limited Discoverability**: Users must manually explore each component to understand plugin functionality, creating barriers to adoption
5. **Missing Documentation Sites**: No automatic generation of browsable documentation sites from existing code docstrings, similar to what `mkdocstrings` provides for regular Python packages

These limitations hinder both plugin adoption and development, as users struggle to understand plugin capabilities and developers cannot leverage their existing docstring investments for comprehensive documentation.

Rationale
=========

The design builds upon OEP-3's plugin infrastructure while providing `mkdocstrings`-like functionality for plugins:

**Automatic Docstring Extraction**: Similar to `mkdocstrings`, the system automatically discovers and extracts docstrings from all plugin components without requiring manual documentation maintenance.

**Source Code Analysis**: Performs deep analysis of plugin source code to extract function signatures, class hierarchies, parameter information, and comprehensive docstring content.

**Zero-Maintenance Documentation**: Plugin developers only need to write good docstrings in their code - comprehensive plugin documentation is automatically generated and kept in sync.

**Multiple Output Formats**: Generates documentation for both CLI display and MkDocs-compatible sites, integrating seamlessly with existing `mkdocstrings` workflows.

**Plugin-Aware Aggregation**: Unlike generic `mkdocstrings`, this system understands OWA's plugin structure and automatically organizes documentation by namespace, component type, and functional relationships.

**Lazy Documentation Generation**: Documentation is generated on-demand, maintaining OEP-3's performance benefits while providing comprehensive information when needed.

The design prioritizes zero-maintenance documentation generation, leveraging existing docstring investments while providing plugin-specific organization and presentation.

Specification
=============

## Automatic Source Code Documentation Extraction

### Plugin Documentation from Source Code

The system automatically extracts comprehensive documentation directly from plugin source code, similar to `mkdocstrings`:

```python
# Example plugin component with rich docstrings
def click(x: int, y: int, button: str = "left") -> None:
    """Perform a mouse click at specified coordinates.

    This function simulates a mouse click at the given screen coordinates
    using the specified mouse button. Coordinates are relative to the
    primary display's top-left corner.

    Args:
        x: X coordinate for click position (0-based from left edge)
        y: Y coordinate for click position (0-based from top edge)
        button: Mouse button to click. Options: "left", "right", "middle"

    Returns:
        None

    Raises:
        ValueError: If coordinates are outside screen bounds
        OSError: If mouse input simulation fails

    Examples:
        Basic left click:
        >>> click(100, 200)

        Right click for context menu:
        >>> click(100, 200, "right")

        Click at screen center:
        >>> import screen
        >>> w, h = screen.get_size()
        >>> click(w//2, h//2)

    Note:
        Requires appropriate permissions on some systems.
        Use screen.get_size() to determine valid coordinate ranges.
    """
    # Implementation here...

class MouseListener:
    """Listen for mouse events and execute callbacks.

    This class provides a high-level interface for monitoring mouse
    events including clicks, movements, and scroll actions. It runs
    in a separate thread to avoid blocking the main application.

    Attributes:
        callback: Function called when mouse events occur
        is_running: Whether the listener is currently active

    Examples:
        Basic mouse event logging:
        >>> def log_mouse(event):
        ...     print(f"Mouse {event.type} at {event.x}, {event.y}")
        >>> listener = MouseListener()
        >>> listener.configure(callback=log_mouse)
        >>> listener.start()

        Click detection with filtering:
        >>> def on_click(event):
        ...     if event.type == "click" and event.button == "left":
        ...         print(f"Left click at {event.x}, {event.y}")
        >>> listener = MouseListener()
        >>> listener.configure(callback=on_click)
        >>> listener.start()
    """

    def configure(self, callback: Callable[[MouseEvent], None]) -> 'MouseListener':
        """Configure the mouse listener with a callback function.

        Args:
            callback: Function to call when mouse events occur.
                     Receives MouseEvent objects with event details.

        Returns:
            Self for method chaining

        Examples:
            >>> listener = MouseListener()
            >>> listener.configure(lambda e: print(e)).start()
        """
        # Implementation here...

    def start(self) -> None:
        """Start listening for mouse events.

        Begins monitoring mouse events in a background thread.
        Events are passed to the configured callback function.

        Raises:
            RuntimeError: If no callback is configured
            OSError: If mouse monitoring cannot be initialized
        """
        # Implementation here...
```

### Automatic Documentation Discovery

The system discovers and processes all plugin components automatically:

```python
from owa.core.documentation import PluginDocumentationExtractor

# Automatic discovery and extraction
extractor = PluginDocumentationExtractor()

# Extract all documentation for a plugin namespace
plugin_docs = extractor.extract_plugin_documentation("example")

# The system automatically:
# 1. Discovers all components via OEP-3 entry points
# 2. Loads source code for each component
# 3. Extracts and parses docstrings (Google, NumPy, Sphinx styles)
# 4. Analyzes function signatures and type hints
# 5. Extracts examples, parameters, return types, exceptions
# 6. Organizes by component type (callables, listeners, runnables)
```

## Automatic Documentation Generation Process

### mkdocstrings-Style Source Analysis

The system performs comprehensive source code analysis similar to `mkdocstrings`:

1. **Component Discovery**: Use OEP-3 entry points to discover all plugin components
2. **Source Code Loading**: Load actual Python source files for each component
3. **AST Analysis**: Parse source code using Python's AST module for structural analysis
4. **Docstring Extraction**: Extract and parse docstrings using multiple format parsers
5. **Signature Analysis**: Extract function/class signatures with type hints
6. **Cross-Reference Resolution**: Resolve imports and dependencies between components
7. **Documentation Assembly**: Organize extracted information into plugin-level documentation

### Zero-Configuration Documentation Generation

```python
from owa.core.documentation import PluginDocumentationGenerator

# Automatic generation - no manual configuration needed
generator = PluginDocumentationGenerator()

# Generate documentation for a specific plugin
plugin_docs = generator.generate_plugin_documentation("example")
# Automatically extracts from:
# - owa.env.example.mouse:click function docstring
# - owa.env.example.listeners:MouseListener class docstring
# - All component signatures and type hints
# - Examples from docstrings
# - Parameter descriptions and types

# Generate documentation for a specific component
component_docs = generator.generate_component_documentation("example", "mouse.click")
# Returns complete documentation extracted from source code

# Generate ecosystem-wide documentation
ecosystem_docs = generator.generate_ecosystem_documentation()
# Processes all discovered plugins automatically
```

### Extracted Documentation Structure

Documentation extracted from source code follows a comprehensive structure:

```python
@dataclass
class PluginDocumentation:
    namespace: str
    version: str  # From PluginSpec
    description: str  # From PluginSpec
    author: str  # From PluginSpec
    components: Dict[str, List[ComponentDocumentation]]
    generated_at: datetime
    source_files: List[str]  # Source files analyzed

@dataclass
class ComponentDocumentation:
    name: str
    full_name: str  # namespace/name
    type: str  # callables, listeners, runnables
    source_file: str
    line_number: int

    # Extracted from docstring
    summary: str
    description: str
    parameters: List[ParameterDocumentation]
    returns: Optional[ReturnDocumentation]
    raises: List[ExceptionDocumentation]
    examples: List[ExampleDocumentation]
    notes: List[str]

    # Extracted from signature analysis
    signature: str
    type_hints: Dict[str, str]
    is_async: bool
    is_method: bool
    is_classmethod: bool
    is_staticmethod: bool

    # For classes
    methods: List['ComponentDocumentation']
    attributes: List[AttributeDocumentation]
    inheritance: List[str]

@dataclass
class ParameterDocumentation:
    name: str
    type: Optional[str]
    default: Optional[str]
    description: str
    is_optional: bool

@dataclass
class ExampleDocumentation:
    code: str
    description: Optional[str]
    expected_output: Optional[str]
    is_doctest: bool
```

## Enhanced CLI Documentation Commands

### Extended `owl env` Commands

The CLI is enhanced with comprehensive documentation display capabilities:

```bash
# Plugin documentation display
$ owl env docs <namespace>                    # Show complete plugin documentation
$ owl env docs <namespace> --format markdown  # Output in markdown format
$ owl env docs <namespace> --format json      # Output in JSON format
$ owl env docs <namespace> --save docs.md     # Save to file

# Component-specific documentation
$ owl env docs <namespace> <component>        # Show specific component docs
$ owl env docs <namespace> --type callables   # Show only callables documentation

# Documentation generation
$ owl env generate-docs                       # Generate documentation site
$ owl env generate-docs --output ./docs       # Specify output directory
$ owl env generate-docs --format mkdocs       # Generate MkDocs-compatible site

# Documentation validation
$ owl env validate-docs <namespace>           # Validate plugin documentation
$ owl env validate-docs --all                 # Validate all plugin documentation
```

### CLI Output Examples

```bash
$ owl env docs example
📚 Plugin Documentation: example v0.1.0 (Auto-generated from source code)
├── 👤 Author: OWA Development Team
├── 📝 Description: Example environment plugin demonstrating the plugin system
├── � Source Files: 4 files analyzed
│   ├── owa/env/example/example_callable.py
│   ├── owa/env/example/example_listener.py
│   ├── owa/env/example/example_runnable.py
│   └── owa/env/example/__init__.py
├── 📞 Callables (3) - Extracted from source docstrings
│   ├── example/mouse.click
│   │   ├── 📝 Perform a mouse click at specified coordinates
│   │   ├── � Source: owa.env.example.mouse:click (line 15)
│   │   ├── �🔧 Signature: click(x: int, y: int, button: str = "left") -> None
│   │   ├── � Parameters:
│   │   │   ├── x (int): X coordinate for click position (0-based from left edge)
│   │   │   ├── y (int): Y coordinate for click position (0-based from top edge)
│   │   │   └── button (str, default="left"): Mouse button to click. Options: "left", "right", "middle"
│   │   ├── 🔄 Returns: None
│   │   ├── ⚠️  Raises:
│   │   │   ├── ValueError: If coordinates are outside screen bounds
│   │   │   └── OSError: If mouse input simulation fails
│   │   ├── 💡 Examples (3 from docstring):
│   │   │   ├── Basic left click:
│   │   │   │   >>> click(100, 200)
│   │   │   ├── Right click for context menu:
│   │   │   │   >>> click(100, 200, "right")
│   │   │   └── Click at screen center:
│   │   │       >>> import screen
│   │   │       >>> w, h = screen.get_size()
│   │   │       >>> click(w//2, h//2)
│   │   └── 📝 Notes:
│   │       ├── Requires appropriate permissions on some systems
│   │       └── Use screen.get_size() to determine valid coordinate ranges
│   ├── example/add
│   │   ├── 📝 Add two numbers together
│   │   ├── 📍 Source: owa.env.example.example_callable:example_add (line 45)
│   │   ├── 🔧 Signature: example_add(a: int, b: int) -> int
│   │   ├── � Parameters:
│   │   │   ├── a (int): First number to add
│   │   │   └── b (int): Second number to add
│   │   ├── 🔄 Returns: int - Sum of the two numbers
│   │   └── 💡 Example:
│   │       >>> example_add(5, 3)
│   │       8
│   └── example/print
│       ├── 📝 Enhanced print function with formatting options
│       ├── 📍 Source: owa.env.example.example_callable:example_print (line 60)
│       └── 🔧 Signature: example_print(message: str, prefix: str = "[OWA]") -> None
├── 👂 Listeners (2) - Extracted from source docstrings
│   ├── example/mouse
│   │   ├── 📝 Listen for mouse events and execute callbacks
│   │   ├── 📍 Source: owa.env.example.listeners:MouseListener (line 25)
│   │   ├── 🔧 Class: MouseListener
│   │   ├── 📋 Attributes:
│   │   │   ├── callback: Function called when mouse events occur
│   │   │   └── is_running: Whether the listener is currently active
│   │   ├── � Methods:
│   │   │   ├── configure(callback: Callable[[MouseEvent], None]) -> MouseListener
│   │   │   │   └── Configure the mouse listener with a callback function
│   │   │   └── start() -> None
│   │   │       └── Start listening for mouse events
│   │   └── 💡 Examples (2 from class docstring):
│   │       ├── Basic mouse event logging:
│   │       │   >>> def log_mouse(event):
│   │       │   ...     print(f"Mouse {event.type} at {event.x}, {event.y}")
│   │       │   >>> listener = MouseListener()
│   │       │   >>> listener.configure(callback=log_mouse).start()
│   │       └── Click detection with filtering:
│   │           >>> def on_click(event):
│   │           ...     if event.type == "click" and event.button == "left":
│   │           ...         print(f"Left click at {event.x}, {event.y}")
│   │           >>> MouseListener().configure(callback=on_click).start()
│   └── example/timer
│       ├── 📝 Timer-based event listener for periodic callbacks
│       ├── 📍 Source: owa.env.example.example_listener:ExampleTimerListener (line 80)
│       └── � Class: ExampleTimerListener(interval: float = 1.0)
└── 🏃 Runnables (2) - Extracted from source docstrings
    ├── example/counter
    │   ├── 📝 A simple counter that increments periodically
    │   ├── 📍 Source: owa.env.example.example_runnable:ExampleCounterRunnable (line 15)
    │   └── 🔧 Class: ExampleCounterRunnable(start_value: int = 0, increment: int = 1)
    └── example/processor
        ├── 📝 Process data items in batches with configurable batch size
        ├── 📍 Source: owa.env.example.example_runnable:DataProcessor (line 45)
        └── 🔧 Class: DataProcessor(batch_size: int = 100)

$ owl env docs example mouse.click
🔍 Component Documentation: example/mouse.click
├── 📝 Description: Perform a mouse click at specified coordinates
├── 🔧 Signature: click(x: int, y: int, button: str = "left") -> None
├── 📍 Parameters
│   ├── x (int): X coordinate for click position
│   ├── y (int): Y coordinate for click position
│   └── button (str, optional): Mouse button to click ("left", "right", "middle")
├── 🔄 Returns: None
├── 📍 Source: owa.env.example.mouse:click
├── 💡 Examples
│   ├── Basic click:
│   │   CALLABLES["example/mouse.click"](100, 200)
│   └── Right click:
│       CALLABLES["example/mouse.click"](100, 200, "right")
└── ⚠️  Notes
    Coordinates are relative to the primary display. Use screen.get_size()
    to determine valid coordinate ranges.
```

## Automatic Documentation Site Generation

### MkDocs Integration with mkdocstrings-style Processing

The system generates MkDocs-compatible documentation sites using automatic docstring extraction:

```bash
$ owl env generate-docs --format mkdocs --output ./docs
📚 Generating documentation site from source code...
├── � Discovering plugins via entry points
├── �📁 Creating directory structure
├── � Analyzing source code for 4 plugins
│   ├── Extracting docstrings from example plugin (7 components)
│   ├── Extracting docstrings from desktop plugin (25 components)
│   ├── Extracting docstrings from gst plugin (4 components)
│   └── Extracting docstrings from std plugin (2 components)
├── �📝 Generating plugin pages from extracted documentation
├── 🔗 Creating navigation structure
├── 🎨 Applying OWA theme and styling
└── ✅ Documentation site generated at ./docs (38 components documented)

$ cd docs && mkdocs serve
INFO    -  Building documentation...
INFO    -  Cleaning site directory
INFO    -  Documentation built in 0.45 seconds
INFO    -  [15:30:45] Serving on http://127.0.0.1:8000/
```

### Generated Site Structure (Auto-generated from Source Code)

```
docs/
├── mkdocs.yml                 # MkDocs configuration with auto-generated nav
├── docs/
│   ├── index.md              # Ecosystem overview (auto-generated)
│   ├── plugins/
│   │   ├── index.md          # Plugin index (auto-generated)
│   │   ├── example.md        # Auto-generated from owa.env.example source
│   │   ├── desktop.md        # Auto-generated from owa.env.desktop source
│   │   ├── gst.md           # Auto-generated from owa.env.gst source
│   │   └── std.md           # Auto-generated from owa.env.std source
│   ├── components/
│   │   ├── callables.md      # Auto-generated callables overview
│   │   ├── listeners.md      # Auto-generated listeners overview
│   │   └── runnables.md      # Auto-generated runnables overview
│   └── api/                  # Detailed API docs (extracted from docstrings)
│       ├── example/
│       │   ├── mouse.click.md      # From click() function docstring
│       │   ├── add.md              # From example_add() function docstring
│       │   ├── print.md            # From example_print() function docstring
│       │   ├── mouse-listener.md   # From MouseListener class docstring
│       │   └── timer-listener.md   # From ExampleTimerListener class docstring
│       ├── desktop/
│       │   ├── keyboard.type.md    # From keyboard_type() function docstring
│       │   ├── mouse.click.md      # From click() function docstring
│       │   ├── window.get_active.md # From get_active_window() function docstring
│       │   └── screen.capture.md   # From capture_screen() function docstring
│       ├── gst/
│       │   └── screen-listener.md  # From ScreenListener class docstring
│       └── std/
│           ├── time_ns.md          # From time_ns function docstring
│           └── tick-listener.md    # From ClockTickListener class docstring
└── theme/                    # Custom OWA theme assets
    ├── css/
    └── js/
```

### Documentation Templates

The system uses customizable templates for consistent documentation generation:

```python
# Template configuration
DOCUMENTATION_TEMPLATES = {
    "plugin_overview": "templates/plugin_overview.md.jinja2",
    "component_detail": "templates/component_detail.md.jinja2",
    "ecosystem_index": "templates/ecosystem_index.md.jinja2",
    "api_reference": "templates/api_reference.md.jinja2"
}

# Custom template example
"""
# {{ plugin.namespace }} Plugin

{{ plugin.description }}

## Overview
{{ plugin.overview }}

## Components
{% for component_type, components in plugin.components.items() %}
### {{ component_type.title() }}
{% for component in components %}
- [{{ component.name }}]({{ component.link }}) - {{ component.docstring.summary }}
{% endfor %}
{% endfor %}
"""
```

## Documentation Parsing and Analysis

### Docstring Processing

The system intelligently parses various docstring formats:

```python
from owa.core.documentation import DocstringParser

parser = DocstringParser()

# Supports multiple formats
google_style = """
Perform a mouse click at specified coordinates.

Args:
    x (int): X coordinate for click position
    y (int): Y coordinate for click position
    button (str, optional): Mouse button to click. Defaults to "left".

Returns:
    None

Raises:
    ValueError: If coordinates are outside screen bounds

Example:
    >>> click(100, 200, "left")
    >>> click(50, 75, "right")
"""

numpy_style = """
Perform a mouse click at specified coordinates.

Parameters
----------
x : int
    X coordinate for click position
y : int
    Y coordinate for click position
button : str, optional
    Mouse button to click, by default "left"

Returns
-------
None

Examples
--------
>>> click(100, 200, "left")
>>> click(50, 75, "right")
"""

# Parse and extract structured information
parsed = parser.parse(google_style)
# Returns: DocstringInfo with summary, parameters, returns, examples, etc.
```

### Signature Inspection

Automatic signature extraction and analysis:

```python
from owa.core.documentation import SignatureInspector

inspector = SignatureInspector()

# Extract detailed signature information
sig_info = inspector.inspect_component("example/mouse.click")

# Returns structured signature data:
# {
#     "name": "click",
#     "parameters": [
#         {"name": "x", "type": "int", "default": None, "description": "..."},
#         {"name": "y", "type": "int", "default": None, "description": "..."},
#         {"name": "button", "type": "str", "default": "left", "description": "..."}
#     ],
#     "return_type": "None",
#     "is_async": False,
#     "is_method": False
# }
```

## Integration with Existing Systems

### Backward Compatibility with OEP-3

The documentation system seamlessly integrates with existing OEP-3 infrastructure:

- **No Breaking Changes**: Existing plugins continue to work without modification
- **Optional Documentation**: Plugin-level documentation is optional; component docstrings are automatically extracted
- **Lazy Loading Preserved**: Documentation generation doesn't affect component loading performance
- **CLI Enhancement**: Extends existing `owl env` commands without changing core functionality

### Enhanced Component Discovery

Documentation enhances the existing component discovery system:

```python
from owa.core import list_components, get_component_documentation

# Enhanced listing with documentation preview
components = list_components("callables", include_docs=True)
# Returns: {
#   "example/mouse.click": {
#     "summary": "Perform a mouse click at specified coordinates",
#     "parameters": ["x", "y", "button"],
#     "tags": ["input", "automation"]
#   }
# }

# Quick documentation access
docs = get_component_documentation("example/mouse.click")
print(docs.summary)  # "Perform a mouse click at specified coordinates"
```

Backwards Compatibility
=======================

This OEP maintains full backward compatibility with OEP-3:

**No Breaking Changes:**
- Existing `PluginSpec` objects continue to work without modification
- Component registration and access patterns remain unchanged
- CLI commands maintain existing functionality while adding new capabilities
- Lazy loading performance characteristics are preserved

**Optional Enhancements:**
- Plugin-level documentation is entirely optional
- Component docstrings are automatically extracted from existing code
- Enhanced CLI commands are additive, not replacements
- Documentation generation is on-demand and doesn't affect runtime performance

**Migration Path:**
- **Phase 1**: Use automatic docstring extraction with existing plugins
- **Phase 2**: Optionally add plugin-level documentation to `PluginSpec`
- **Phase 3**: Leverage enhanced CLI commands and documentation sites
- **Phase 4**: Integrate with automated documentation workflows

Security Implications
=====================

The documentation generation system introduces minimal security considerations:

**Reduced Risk:**
- Documentation generation is read-only and doesn't modify plugin code
- Lazy loading principles prevent unnecessary code execution
- Template system uses safe rendering without code execution

**Considerations:**
- Docstring content is trusted and displayed without sanitization
- Generated documentation sites should be served securely
- Plugin metadata should be validated to prevent injection attacks

**Mitigation Strategies:**
- Validate plugin metadata during documentation generation
- Sanitize user-provided documentation content for web display
- Implement access controls for documentation generation commands
- Provide options to exclude sensitive information from generated docs

How to Teach This
=================

The documentation system can be taught through progressive examples emphasizing zero-maintenance documentation:

### 1. Basic Usage (Viewing Auto-Generated Documentation)
```bash
# View automatically generated plugin documentation
$ owl env docs example
$ owl env docs example mouse.click

# All documentation is extracted from existing source code docstrings
# No manual documentation files needed!
```

### 2. Writing Good Docstrings for Auto-Generation
```python
def my_function(x: int, y: str = "default") -> bool:
    """Short description of what the function does.

    Longer description explaining the function's purpose,
    behavior, and any important details.

    Args:
        x: Description of the x parameter
        y: Description of the y parameter with default value

    Returns:
        Description of what the function returns

    Raises:
        ValueError: When this exception might be raised

    Examples:
        >>> my_function(42, "test")
        True
        >>> my_function(0)
        False

    Note:
        Any additional notes or warnings
    """
    # Implementation here...

# The system automatically extracts ALL of this information:
# - Summary and description
# - Parameter types and descriptions
# - Return type and description
# - Exception information
# - Examples (including doctests)
# - Notes and warnings
```

### 3. Zero-Maintenance Documentation Sites
```bash
# Generate comprehensive documentation site from source code
$ owl env generate-docs --format mkdocs
# Creates complete MkDocs site from existing docstrings
# No manual .md files to maintain!

$ cd docs && mkdocs serve
# Browse auto-generated documentation
```

### 4. Integration with Existing Workflows
```python
# Works with existing mkdocstrings setup
# Add to existing mkdocs.yml:
plugins:
  - mkdocstrings:
      handlers:
        python:
          paths: [projects]
  - owa-env-docs:  # New plugin for OWA-specific documentation
      auto_discover: true
      include_source_links: true
```

**Key Teaching Points:**
- **Zero Maintenance**: Write good docstrings once, get comprehensive documentation forever
- **Automatic Sync**: Documentation always matches code because it IS the code
- **mkdocstrings Philosophy**: Similar to `mkdocstrings` but plugin-aware
- **Developer Productivity**: Focus on code and docstrings, not separate documentation files
- **Standards Compliance**: Uses standard Python docstring formats (Google, NumPy, Sphinx)

Reference Implementation
========================

The reference implementation will be available in `owa-core`:

**Core Components:**
- `owa.core.documentation.DocumentationGenerator` - Main documentation generation engine
- `owa.core.documentation.DocstringParser` - Multi-format docstring parsing
- `owa.core.documentation.SignatureInspector` - Automatic signature analysis
- `owa.core.documentation.TemplateEngine` - Customizable documentation templates
- `owa.core.cli.docs` - Enhanced CLI commands for documentation

**CLI Integration:**
- Extended `owl env docs` command with comprehensive display options
- New `owl env generate-docs` command for site generation
- Enhanced `owl env validate-docs` for documentation quality assurance

**Documentation Templates:**
- Default templates for plugin overview, component details, and API reference
- Customizable Jinja2 templates for different output formats
- MkDocs theme integration with OWA branding

**Example Implementations:**
- Updated `owa-env-example` with comprehensive plugin documentation
- Migration examples showing documentation enhancement for existing plugins
- Integration examples with popular documentation workflows

**Testing:**
- Comprehensive test suite covering documentation generation, parsing, and CLI commands
- Performance benchmarks ensuring minimal impact on plugin loading
- Integration tests with real plugin ecosystems

The implementation prioritizes ease of use, performance, and integration with existing OEP-3 infrastructure while providing powerful documentation capabilities.

Rejected Ideas
==============

### Manual Documentation in PluginSpec

Adding comprehensive documentation fields to `PluginSpec` was considered but rejected because:
- Creates maintenance overhead and synchronization issues between code and documentation
- Duplicates information already present in docstrings
- Doesn't leverage existing docstring investments
- Goes against the `mkdocstrings` philosophy of single-source documentation
- Requires plugin developers to maintain documentation in two places

### Configuration-Based Documentation

Using configuration files to specify documentation structure was considered but rejected because:
- Adds complexity and maintenance overhead
- Doesn't automatically stay in sync with code changes
- Requires manual updates when components are added/removed
- Conflicts with the zero-maintenance goal
- `mkdocstrings` demonstrates that automatic extraction is superior

### Runtime Documentation Generation

Generating documentation at plugin load time was considered but rejected because:
- Would impact the performance benefits of OEP-3's lazy loading
- Unnecessary overhead for users who don't need documentation
- Conflicts with the on-demand principle of the plugin system
- Could cause startup delays in production environments

### Generic mkdocstrings Integration Only

Using only the standard `mkdocstrings` plugin without OWA-specific enhancements was considered but rejected because:
- Doesn't understand OWA's plugin structure and component organization
- Can't provide plugin-level aggregation and overview
- Lacks CLI integration for quick reference
- Doesn't integrate with OWA's entry points discovery system
- Misses the opportunity to provide plugin-specific navigation and organization

### Separate Documentation Repositories

Maintaining documentation in separate repositories was considered but rejected because:
- Creates synchronization issues between code and documentation
- Doesn't leverage the `mkdocstrings` approach of documentation-from-code
- Requires additional maintenance overhead
- Makes it difficult to ensure documentation accuracy
- Goes against modern documentation best practices

Open Issues
===========

While the core specification is complete, several areas warrant further discussion:

### Documentation Quality Standards

- Should there be minimum documentation requirements for plugins?
- How should documentation quality be measured and enforced?
- What guidelines should be provided for effective plugin documentation?

### Internationalization Support

- Should the documentation system support multiple languages?
- How should localized documentation be structured and managed?
- What impact would internationalization have on CLI output and web sites?

### Advanced Documentation Features

- Should the system support interactive documentation (executable examples)?
- How should version-specific documentation be handled?
- What additional metadata would be valuable for plugin discovery?

### Integration with Package Managers

- Should documentation be integrated with PyPI package descriptions?
- How should documentation versioning align with package versioning?
- What opportunities exist for documentation-based package discovery?

References
==========

- **OEP-3**: Entry Points-Based Plugin Discovery and Unified Component Naming
- **Python Packaging Guide**: https://packaging.python.org/en/latest/
- **MkDocs Documentation**: https://www.mkdocs.org/
- **Sphinx Documentation**: https://www.sphinx-doc.org/
- **Google Style Docstrings**: https://google.github.io/styleguide/pyguide.html
- **NumPy Style Docstrings**: https://numpydoc.readthedocs.io/en/latest/format.html

Copyright
=========

This document is placed in the public domain or under the CC0-1.0-Universal license, whichever is more permissive.
